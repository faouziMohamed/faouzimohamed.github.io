<!DOCTYPE html onchange='alert("moi")'>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <title>R√©seaux de neurones convolutionnels</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name='author' content="Faouzi Mohamed">
    <meta name="color-scheme" content="dark light">
    <link rel="stylesheet" type="text/css" href="../css/style.css">

    <script>
        MathJax = {
            tex: {
                inlineMath: [
                    ['$', '$'],
                    ['\\(', '\\)']
                ]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <!--<script id="MathJax-script" async src="../mathjax/es5/tex-svg-full.js"></script>-->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <noscript>
        <link rel="stylesheet" href="../css/noscript.css" />
    </noscript>

</head>

<body>
    <span id="top"></span>
    <nav id='header-nav'>
        <div id="menu-icon-wrapper">
            <svg version="1.1" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000"
                xml:space="preserve" width="32" height='32'>
                <g>
                    <path d="M896.6,291.5H103.5c-51.5,0-93.5-41.9-93.5-93.5c0-51.5,
                        41.9-93.5,93.5-93.5h793.1c51.5,0,93.4,41.9,93.4,93.5C990,249.5,
                        948.1,291.5,896.6,291.5z M103.5,130.8c-37.1,0-67.2,30.2-67.2,
                        67.2s30.2,67.2,67.2,67.2h793.1c37,0,67.2-30.2,
                        67.2-67.2s-30.1-67.2-67.2-67.2H103.5z" />
                    <path d="M733.7,593.5H103.5C51.9,593.5,10,551.5,10,500c0-51.5,
                        41.9-93.4,93.5-93.4h630.2c51.5,0,93.4,41.9,93.4,93.4C827.1,551.5,
                        785.2,593.5,733.7,593.5z M103.5,432.8c-37.1,0-67.2,30.2-67.2,67.2c0,
                        37.1,30.2,67.2,67.2,67.2h630.2c37.1,0,67.2-30.2,
                        67.2-67.2c0-37-30.1-67.2-67.2-67.2H103.5z" />
                    <path d="M570.9,895.4H103.5c-51.5,0-93.5-41.9-93.5-93.4c0-51.5,41.9-93.5,
                        93.5-93.5h467.4c51.5,0.1,93.4,42,93.4,93.5C664.3,853.6,622.4,895.4,570.9,
                        895.4z M103.5,734.8c-37.1,0-67.2,30.2-67.2,67.2c0,37,30.2,67.1,67.2,67.1h467.4c37,
                        0,67.2-30.1,67.2-67.1s-30.1-67.2-67.2-67.2H103.5z" />
                </g>
            </svg>
        </div>
        <ul id="main-list">
            <li>
                <a href="../index.html">
                    <svg id="home" version="1.1" x="0px" y="0px" viewBox="0 0 1000 1000"
                        enable-background="new 0 0 1000 1000" xml:space="preserve" width="25" height="25">
                        <g>
                            <path d="M834.6,812.2V413.9L488.3,253.7L140.7,422.6v389.6c0,47.8,19.7,86.6,
                            43.9,86.6h43.9V634.5c0-9.5,7.7-17.1,17.1-17.1h151.9c9.5,0,17.1,7.7,17.1,
                            17.1v264.3h333.4C795.9,898.8,834.6,860,834.6,812.2z M624.7,786.1c0,9.5-7.7,
                            17.1-17.1,17.1h-47.2c-9.4,0-17.1-7.7-17.1-17.1v-47.2c0-9.4,7.7-17.1,
                            17.1-17.1h47.2c9.4,0,17.1,7.7,17.1,17.1V786.1z M624.7,683.4c0,9.5-7.7,
                            17.1-17.1,17.1h-47.2c-9.4,0-17.1-7.7-17.1-17.1v-47.2c0-9.4,7.7-17.1,
                            17.1-17.1h47.2c9.4,0,17.1,7.7,17.1,17.1V683.4z M727.8,786.1c0,9.5-7.7,17.1-17.1,
                            17.1h-47.2c-9.5,0-17.1-7.7-17.1-17.1v-47.2c0-9.4,7.7-17.1,17.1-17.1h47.2c9.4,0,
                            17.1,7.7,17.1,17.1V786.1z M727.8,683.4c0,9.5-7.7,17.1-17.1,17.1h-47.2c-9.5,
                            0-17.1-7.7-17.1-17.1v-47.2c0-9.4,7.7-17.1,17.1-17.1h47.2c9.4,0,17.1,7.7,17.1,
                            17.1V683.4z" />
                            <path d="M960.6,317.6l-126-59.6v-44c0-32.8-23-59.3-51.4-59.3c-27,0-49,24.2-51,
                            54.9L513.8,106.1c-14.2-6.7-30.6-6.6-44.6,0.3L38.7,318c-25.5,12.5-36,43.3-23.5,
                            68.7c12.5,25.4,43.3,35.9,68.7,23.5l408.3-200.6l424.4,200.9c7.1,3.4,14.6,4.9,22,
                            4.9c19.2,0,37.7-10.8,46.4-29.4C997.2,360.4,986.2,329.8,960.6,317.6z" />
                        </g>
                    </svg>
                    <span class="li-label">Acceuil</span>
                </a>
            </li>
            <li>
                <a href="contexte.html">
                    <svg version="1.1" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000"
                        xml:space="preserve" width="32" height="32">
                        <g>
                            <g transform="translate(0.000000,511.000000) scale(0.100000,-0.100000)">
                                <path d="M290.7,3020.7c-83.7-36.8-169.5-140.9-183.8-222.6c-6.1-36.8-8.2-1270.4-6.1-2744.9c6.1-2669.4,
                                6.1-2679.6,49-2734.7c22.5-30.6,67.4-75.6,98-98l55.1-42.9l3986.7-6.1c2193.5-2.1,
                                4015.3,0,4052,6.1c145,26.6,161.3,53.1,876.2,1484.8C9767.2-236.8,9900,43,9900,
                                108.3c0,65.4-132.8,345.2-682.1,1444c-375.8,751.6-702.6,1384.7-729.1,1409.2c-26.6,
                                24.5-75.6,53.1-106.2,65.4c-40.8,16.3-1268.3,22.5-4043.9,22.5C1070.9,3047.3,341.8,
                                3043.2,290.7,3020.7z M8633.7,
                                1252.1l571.9-1143.7l-571.9-1143.7l-571.9-1143.7H4406.1H750.2V108.3v2287.4h3655.8h3655.8L8633.7,
                                1252.1z" />
                                <path d="M7042.7,1056C6526,917.1,6205.4,380,6336.1-126.5c136.8-520.8,674-847.6,1180.5-714.8c181.8,
                                47,318.6,126.6,455.4,263.5c251.2,251.2,349.2,590.2,263.5,917C8098.6,868.1,7555.4,1194.9,7042.7,
                                1056z M7414.4,406.5c210.4-87.8,261.4-361.5,98-524.9c-132.8-132.8-320.6-132.8-453.4,0C6805.8,132.9,
                                7085.6,545.4,7414.4,406.5z" />
                            </g>
                        </g>
                    </svg><span class="li-txt">Contexte</span>
                </a>
            </li>
            <li class="submenu-parent">
                <a href="#">
                    <svg version="1.1" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000"
                        xml:space="preserve" width="32" height="32">
                        <g>
                            <path d="M504,483.9c-3.4,0-6.7-0.7-9.9-2.2l-452-213c-8.1-3.7-13.2-11.7-13.4-20.8c-0.1-9.1,
                            5-17.2,13.1-21.2L490.4,12.3c6.3-3,13.8-3,20.1,0L958,225.2c8.2,3.9,13.2,11.9,13.2,21c0,
                            9.1-5.1,17.1-13.3,21L514.2,481.6C510.9,483.1,507.5,483.9,504,483.9L504,483.9L504,
                            483.9z M82.1,247.6L504,446.4l414.1-200.1L500.5,47.5L82.1,247.6L82.1,247.6L82.1,247.6z" />
                            <path d="M503.8,990c-3.4,0-6.8-0.7-10-2.2L39.6,774.3c-8.1-3.7-13.2-11.7-13.4-20.8c-0.1-9.1,
                            5-17.2,13.1-21.2l100.2-48l15.6,32.6l-75.6,36.2l424.1,199.3l417-202l-76-36.1l15.5-32.6l100.3,
                            47.6c8.2,3.9,13.3,11.9,13.3,21c0,9.1-5,17.1-13.2,21L513.9,987.6C510.7,989.2,507.3,
                            990,503.8,990" />
                            <path d="M75,755.3l-22.5-29.3l146.9-70.6l42.2,20.2L75,755.3z" />
                            <path d="M921.6,751.2l-158.4-75.2l41.5-20.7l150.5,71.5L921.6,751.2z" />
                            <path d="M503.7,734.7c-3.2,0-6.5-0.7-9.5-2L39.6,519.1c-8.2-3.9-13.3-11.9-13.4-21c0-9.1,
                            5.1-17.2,13.3-21l100.1-48l15.6,32.6L79.5,498l424.1,199.3l417-202l-76-36.1l15.5-32.6l100.3,
                            47.6c8.1,3.9,13.2,11.9,13.3,20.9c0,9.1-4.9,17.1-13.1,21L513.9,732.4C510.6,734,507.2,
                            734.7,503.7,734.7" />
                            <path d="M804.3,400.3l150.1,70.9l-32.8,24.7l-158.4-75.2L804.3,400.3z" />
                            <path d="M76.9,499.2l-18.7-31.1l142.1-68.2l41.2,20.5L76.9,499.2z" />
                        </g>
                    </svg><span class="li-txt">Deep learning</span>
                </a>
                <ul class="submenu">
                    <li><a href="nn.html">R√©seaux de neurones</a></li>
                    <li><a href="cnn.html">R√©seaux de neurones convolutionnels</a></li>
                </ul>
            </li>
            <li class="submenu-parent">
                <a href="#">
                    <svg version="1.1" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000"
                        xml:space="preserve" width="32" height="32">
                        <g>
                            <path d="M761.3,663.3H238.7v65.3h522.7V663.3z M696,
                            271.3H565.3V10H434.7v261.3H304l196,196L696,271.3z M761.3,336.9v65.4l65.3,
                            65h-65.3v65.3h65.3v392H173.3v-588h65.3v-65.3H108V990h784V468L761.3,
                            336.9z M238.7,859.3h522.7V794H238.7V859.3z" />
                        </g>
                    </svg><span class="li-txt">T√©l√©charger</span>
                </a>
                <ul class="submenu">
                    <li>
                        <a href="#">Le contenu du site en pdf</a>
                    </li>
                </ul>
            </li>
        </ul>
        <label id="switch" class="switch">
            <input type="checkbox" onchange="toggleTheme()" id="slider">
            <span class="slider round"></span>
        </label>
        <a href="#" id="github">
            <svg version="1.1" x="0px" y="0px" width="32" height="32" viewBox="0 0 1000 1000" aria-hidden="true"
                enable-background="new 0 0 1000 1000" xml:space="preserve">
                <g>
                    <g transform="translate(0.000000,511.000000) scale(0.100000,-0.100000)">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M4553.4,
                        4863.8c-619.6-51.6-1218.5-223.7-1769.3-499.1c-805.5-406.2-1404.4-946.6-1903.6-1707.3c-358-543.9-602.4-1160-722.9-1827.8C78.5,399.3,82-447.5,
                        161.1-864c330.5-1724.5,1483.6-3122.1,3077.3-3721c261.6-99.8,364.9-103.3,
                        454.4-13.8c62,62,68.8,113.6,68.8,526.7v454.4h-437.2c-378.6,0-464.7,10.3-602.4,
                        75.7c-271.9,123.9-454.4,323.5-626.5,681.6c-151.5,316.7-344.2,554.2-581.7,
                        722.9c-237.5,168.7-51.6,299.5,285.7,203.1c148-44.8,230.6-96.4,378.6-251.3c103.3-106.7,
                        244.4-268.5,309.8-361.4c75.7-106.7,189.3-206.5,309.8-275.4c165.2-92.9,220.3-106.7,
                        447.5-103.3c141.1,3.5,316.7,27.6,389,51.6c120.5,44.8,137.7,72.3,206.5,275.4c41.3,120.5,110.2,268.5,
                        154.9,323.6l79.2,99.8l-354.6,75.7c-636.8,134.3-998.2,320.1-1325.2,681.6c-337.3,368.3-526.7,943.1-526.7,
                        1604c0,516.3,99.8,846.8,368.3,1211.7l117,161.8l-41.3,210c-72.3,375.2,27.5,1039.6,165.2,1091.2c144.6,55.1,
                        729.7-158.3,1122.1-409.6l161.8-103.3l320.1,62c440.6,89.5,1394.1,92.9,1834.7,3.4l313.3-65.4l302.9,175.6c337.3,
                        192.8,647.1,306.4,874.3,320.1l154.9,10.3l65.4-172.1c86.1-220.3,117.1-709.1,58.5-939.7l-41.3-175.6l154.9-234.1c275.4-419.9,
                        316.7-571.4,316.7-1163.5c-3.4-433.7-13.8-561.1-79.2-791.7c-192.8-671.2-602.4-1108.4-1253-1345.9c-82.6-31-306.4-89.5-502.5-130.8l-354.6-75.7l75.7-92.9c41.3-55.1,
                        106.7-179,144.6-275.4c68.8-161.8,75.7-261.6,86.1-1074c6.9-599,24.1-908.8,51.6-939.7c117.1-144.6,278.8-117.1,836.5,148c671.2,313.2,
                        1363.1,881.2,1820.9,1493.9c426.8,564.5,771.1,1363.1,898.4,2068.8c79.2,437.2,
                        79.2,1215.1,0,1652.3c-199.6,1105-815.8,2182.4-1655.7,2888C7162.6,4560.9,5861.4,4980.8,4553.4,4863.8z" />
                    </g>
                </g>
            </svg>
        </a>
    </nav>
    <!--Main content-->
    <main>
        <aside id="left-aside">
            <nav id="aside-nav">
                <h1>Plan du site</h1>
                <ul id="ul-aside-nav"></ul>
            </nav>
        </aside>
        <article class="main-article" role="doc-chapter">
            <header>
                <h1>Les r√©seaux de neurones convolutionnels</h1>
            </header>
            <section class="main-section" role="doc-introduction">
                <h2>Introduction</h2>
                <p>
                    Les r√©seaux de neurones convolutifs (CNN), sont, jusqu‚Äô√†
                    <span class="dotted-border-bottom has-tooltip">maintenant<span class="tooltip">Maintenant : 2020
                        </span></span>,
                    les meilleurs mod√®les de r√©seaux de neurones pour classifier des images.
                    Elles prennent en entr√©e une image fournie sous la forme
                    d‚Äôune matrice de pixels. Cette matrice est de deux dimensions pour une image en niveau de gris. La
                    couleur est repr√©sent√©e par une troisi√®me dimension, de profondeur 3 pour repr√©senter les couleurs
                    fondamentales
                    [Rouge, Vert, Bleu} (RGB de l'anglais <span lang="en">Red, Green, Blue</span>).
                </p>
                <p>
                    Avant de continuer, rappelons-nous qu‚Äôun CNN est avant tout un r√©seau de neurone que l‚Äôon a juste
                    ajout√© un ou plusieurs couches de convolutions. Donc, les CNN respectent aussi les r√®gles d‚Äôun
                    r√©seau de neurones cit√©s sur cette
                    <a href="nn.html#titre25">section</a> du chapitre
                    <q class="quotation"><a href="nn.html">Les r√©seaux de neurones</a></q>.
                </p>

                <p>
                    Les r√©seaux de neurones convolutifs, ou CNN, ont √©t√© con√ßus pour mapper les donn√©es d'image √† une
                    variable de sortie. Ils se sont r√©v√©l√©s si efficaces qu'ils sont la m√©thode de r√©f√©rence pour tout
                    type de
                    probl√®me de pr√©diction impliquant des donn√©es d'image en entr√©e. L'avantage d'utiliser des CNN est
                    leur
                    capacit√© √† d√©velopper une repr√©sentation interne d'une image bidimensionnelle. Cela permet au mod√®le
                    d'apprendre la position et l'√©chelle dans diff√©rentes structures des donn√©es, ce qui est important
                    lorsque vous
                    travaillez avec des images.
                </p>
                <div class="list-p">
                    <p>L'avantage de CNN est que :</p>
                    <ul>
                        <li>Ils utilisent moins de param√®tres (poids) pour apprendre qu'un r√©seau enti√®rement connect√©.
                        </li>
                        <li>Ils sont con√ßus pour √™tre invariants √† la position et √† la distorsion de l'objet dans
                            l‚Äôimage.
                        </li>
                        <li> Ils apprennent et g√©n√©ralisent automatiquement les fonctionnalit√©s du domaine d'entr√©e.
                        </li>
                    </ul>
                </div>
            </section>

            <section class="main-section">
                <h2>Architecture de r√©seaux de neurone convolutionnel</h2>
                <div role="doc-pagelist" class="lisp-p">
                    <p>Il existe trois types de couches dans un r√©seau neuronal convolutif :</p>
                    <ul>
                        <li><a href="#conv">Couches convolutives</a></li>
                        <li><a href="#pooling">Couches de Pooling.</a></li>
                        <li><a href="#fully-connected">Couches enti√®rement connect√©es (fully-connected)</a></li>
                    </ul>
                </div>
                <section>
                    <h3><span id="conv"></span>Couche de convolution</h3>
                    <p>
                        Les couches convolutives sont compos√©es de <span class='bold'>filtres et de carte de
                            caract√©ristiques</span>.
                        Son but est de rep√©rer la pr√©sence d'un ensemble de caract√©ristiques dans les images re√ßues en
                        entr√©e.
                    </p>
                    <p>
                        Les filtres sont les <q class="quotation">neurones</q>
                        de la couche. Ils ont des poids d'entr√©e et produisent une valeur. La
                        taille d'entr√©e est un <span class="bold">carr√© fixe</span> appel√©
                        <strong class="bold italic"><q>patch</q></strong> ou
                        <strong class="bold italic"><q>champ r√©cepteur</q></strong>.
                        Si la couche convolutionnels est une
                        couche d'entr√©e, alors le patch d'entr√©e sera des valeurs de pixels. Si la couche est interne
                        (cach√©e), alors la
                        couche convolution prendra l'entr√©e d'une carte de caract√©ristique de la couche pr√©c√©dente.
                    </p>
                    <p>
                        La couche de convolution re√ßoit donc en entr√©e plusieurs images, et calcule la convolution de
                        chacune
                        d'entre elles avec chaque filtre. On obtient pour chaque paire (image, filtre)
                        <strong class="bold italic"><q>une carte d'activation</q></strong>, ou
                        <strong class="bold italic"><q lang="en">feature map</q></strong>,
                        qui nous indique o√π se situent <em>les <span lang="en">features</span> dans l'image</em> : plus
                        la valeur est √©lev√©e, plus
                        l'endroit correspondant dans l'image ressemble √† la <span lang="en">feature</span>.
                    </p>
                    <p>
                        Contrairement aux m√©thodes traditionnelles, les features ne sont pas pr√©d√©finies selon un
                        formalisme
                        particulier (par exemple SIFT), mais apprises par le r√©seau lors la phase d'entra√Ænement ! Les
                        noyaux des
                        filtres d√©signent les poids de la couche de convolution. Ils sont initialis√©s puis mis √† jour
                        par
                        <a href="nn.html#titre19">r√©tropropagation du gradient</a>.
                    </p>
                    <section>
                        <h4>Qu'est-ce qu'une convolution ?</h4>
                        <p role="definition">
                            Une convolution est un filtre qui passe sur une image, la traite et extrait des
                            caract√©ristiques qui
                            montrent une similitude dans l'image. Un filtre est tout simplement un ensemble d‚Äôune
                            matrice qu‚Äôon
                            appelle aussi noyau de convolution ou filtre. Ce filtre on l‚Äôapplique sur un voisinage d‚Äôune
                            image et en
                            sortie on aura une image r√©sultante diff√©rente de l‚Äôoriginal qu‚Äôon appelle <q
                                class="quotation" lang="en"> features map </q>.
                        </p>

                        <div class="figure-layout">
                            <figure id="convolution">
                                <img src="../img/convolution-dark.svg" title="Filtrage d'une image par convolution" alt="Convolution" />
                                <figcaption>Application d'un filtre de convolution</figcaption>
                            </figure>
                        </div>
                        <p>
                            Appliquer donc une convolution consiste √† s√©lectionner un pixel $\boldsymbol{ùíä}$ sur une
                            image, le
                            multiplier par le
                            multiplicateur sur le filtre lui correspondant, et faire de m√™me sur chacun de ses voisins.
                            Enfin la nouvelle
                            valeur du pixel $\boldsymbol{i}$ est la somme de tous ces r√©sultats. La fonction
                            d‚Äôactivation ReLU
                            remplace donc toutes
                            les valeurs n√©gatives re√ßues en entr√©es par des z√©ros. Cela peut sembler √©trange mais voici
                            certains r√©sultats :
                        </p>
                        <div class="figure-layout slide-container">
                            <div>
                                <figure class="slide" id="ex-conv0">
                                    <span class="number-text">1/5</span>
                                    <img src="../img/ex-conv0.svg" alt="Extraction de caract√©ristiques">
                                    <figcaption class="caption-text hide">Extraction de caract√©ristiques</figcaption>
                                </figure>
                                <figure class="slide" id="ex-conv1">
                                    <span class="number-text">2/5</span>
                                    <img src="../img/ex-conv1.svg" alt="D√©tection de lignes">
                                    <figcaption class="caption-text hide">D√©tection de lignes verticales</figcaption>
                                </figure>
                                <figure class="slide" id="ex-conv2">
                                    <span class="number-text">3/5</span>
                                    <img src="../img/ex-conv2.svg" alt="D√©tection de lignes">
                                    <figcaption class="caption-text hide">D√©tection de lignes horizontales</figcaption>
                                </figure>
                                <figure class="slide" id="ex-conv3">
                                    <span class="number-text">4/5</span>
                                    <img src="../img/ex-conv3.svg" alt="D√©tection de formes">
                                    <figcaption class="caption-text hide">D√©tection de formes (<span lang="en">shape</span>)</figcaption>
                                </figure>
                                <figure class="slide" id="ex-conv4">
                                    <span class="number-text">5/5</span>
                                    <img src="../img/ex-conv4.svg" alt="Extraction de caract√©ristiques pour la reconnaisance d'un chat">
                                    <figcaption class="caption-text hide">D√©tection de formes</figcaption>
                                </figure>
                                <a class="prev" onclick="changeImg(-1)"><i class="fas fa-angle-left fa-3x" ></i></a>
                                <a class="next" onclick="changeImg(1)"><i class="fas fa-angle-right fa-3x"></i></a>
                            </div>
                            <div class="dot-wrapper">
                                <span class="dot" onclick="currentSlide(1)"></span>
                                <span class="dot" onclick="currentSlide(2)"></span>
                                <span class="dot" onclick="currentSlide(3)"></span>
                                <span class="dot" onclick="currentSlide(4)"></span>
                                <span class="dot" onclick="currentSlide(5)"></span>
                            </div>
                        </div>
                    </section>
                </section>
                <section>
                    <h3><span id="pooling"></span>Couche de convolution</h3>
                    <p>
                        En plus d'utiliser des convolutions, la mise en commun nous aide grandement √† d√©tecter les
                        fonctionnalit√©s. L'objectif est de r√©duire la quantit√© globale d'informations dans une image,
                        tout en
                        conservant les fonctionnalit√©s d√©tect√©es comme pr√©sentes. Une couche de Pooling est souvent
                        plac√©e entre
                        deux couches de convolution : elle re√ßoit en entr√©e plusieurs feature maps, et applique √†
                        chacune d'entre
                        elles l'op√©ration de pooling. L'op√©ration de pooling consiste √† r√©duire la taille des images,
                        tout en pr√©servant
                        leurs caract√©ristiques importantes.
                    </p>
                    <p>
                        Pour cela, on d√©coupe l'image en cellules r√©guli√®re, puis on garde au sein de chaque cellule la
                        valeur
                        maximale. En pratique, on utilise souvent des cellules carr√©es de petite taille pour ne pas
                        perdre trop
                        d'informations. Les choix les plus communs sont des cellules adjacentes de taille 2 √ó 2 pixels
                        qui ne se
                        chevauchent pas, ou des cellules de taille 3 √ó 3 pixels, distantes les unes des autres d'un pas
                        de 2 pixels
                        (qui se chevauchent donc). On obtient en sortie le m√™me nombre de feature maps qu'en entr√©e,
                        mais celles-
                        ci sont bien plus petites.
                    </p>
                    <p>
                        Il existe diff√©rents types de Pooling, mais dans notre travail, nous en utiliserons un appel√©
                        <strong class="bold">Max Pooling</strong> (<em class="italic">Pooling maximal</em>).
                    </p>
                    <p>
                        L'id√©e ici est d'it√©rer sur l'image et de regarder le pixel et ses voisins imm√©diats √† droite,
                        en dessous et √†
                        droite en dessous. Prenez le plus grand (d'o√π le nom <span class="bold">MAX</span> pooling)
                        d'entre eux et chargez-le dans la
                        nouvelle image. Ainsi, la nouvelle image sera <span class="bold">1/4 de la taille</span> de
                        l'ancienne - les dimensions sur X et Y √©tant
                        divis√©es par deux par ce processus. Les caract√©ristiques sont maintenues malgr√© cette
                        compression.
                    </p>
                    <div class="figure-layout">
                        <figure id="ex-max-pool">
                            <img src="../img/maxPooling.svg" alt="Exemple de max pooling">
                            <figcaption>Pooling maximal</figcaption>
                        </figure>
                    </div>
                </section>
                <section>
                    <h3><span id="fully-connected"></span>Couches enti√®rement connect√©es (fully-connected)</h3>
                    <section>
                        <p>
                            La couche fully-connected constitue toujours la derni√®re couche d'un r√©seau de neurones,
                            convolutif ou non elle n'est donc pas caract√©ristique d'un CNN. La derni√®re couche
                            <q lang="en"><a href="nn.html#titre16">fully-connected</a></q> permet
                            de classifier l'image en entr√©e du r√©seau : elle renvoie un vecteur de taille
                            $\boldsymbol{N}$,
                            o√π $\boldsymbol{N}$ est le nombre de classes dans notre probl√®me de classification d'images.
                            Chaque √©l√©ment du vecteur indique la
                            <em class="bold">probabilit√©</em> pour l'image en entr√©e <span class="bold">d'appartenir √†
                                une classe</span>.
                        </p>
                    </section>
                </section>
                <section>
                    <h3>En r√©sum√©</h3>
                    <p>
                        Le r√©seau de neurones convolutif apprend les valeurs des poids de la m√™me mani√®re qu'il apprend
                        les filtres
                        de la couche de convolution : lors de phase d'entra√Ænement, par r√©tropropagation du gradient. La
                        couche fully-connected d√©termine le lien entre la position des features dans l'image et une
                        classe.
                    </p>
                    <div class="figure-layout">
                        <figure class="resume-cnn">
                            <img src="../img/cnn-summary-dark.svg" alt="R√©seaux de neurones convolutionnel" />
                            <figcaption>R√©seaux de neurones convolutionnel</figcaption>
                        </figure>
                    </div>
                </section>
            </section>

            <section class="main-section">
                <h2>Choix des param√®tres</h2>
                <p>
                    Un r√©seau de neurones convolutif se distingue d'un autre par la fa√ßon dont les couches sont
                    empil√©es, mais
                    √©galement param√©tr√©es. Les couches de convolution et de pooling poss√®dent en effet des
                    hyperparam√®tres,
                    c'est-√†-dire des param√®tres dont vous devez pr√©alablement d√©finir la valeur. Les CNN utilisent plus
                    de
                    param√®tres qu'un MLP standard. M√™me si les r√®gles habituelles pour les taux d'apprentissage et des
                    constantes de r√©gularisation s'appliquent toujours, il faut prendre en consid√©ration les notions de
                    nombre de
                    filtres, leur forme et la forme du max pooling.
                </p>
                <p>
                    Les features de la couche de convolution et les poids de la couche fully-connected ne sont pas des
                    hyperparam√®tres, puisqu'ils sont appris par le r√©seau de neurones lors de la phase d‚Äôentra√Ænement !
                </p>
                <p>
                    La taille des feature maps en sortie des couches de convolution et de pooling d√©pend des
                    hyperparam√®tres.
                    Chaque image (ou feature map) est de dimensions $lxhxd$, o√π $l$ est sa largeur en pixels, $h$ sa
                    hauteur en pixels et $d$
                    le nombre de canaux ($1$ pour une image en noir et blanc, $3$ pour une image en couleurs).
                </p>

                <section>
                    <h3>La couche de convolution</h3>
                    <div class="list-p">
                        <p>La couche de convolution poss√®de quatre hyperparam√®tres :</p>
                        <ol>
                            <li>Le nombre de filtres $\boldsymbol{k}$</li>
                            <li>La taille $\boldsymbol{f}$ des filtres : chaque filtre est de dimensions $\boldsymbol{f
                                √ó f √ó d}$ pixels.</li>
                            <li>Le pas $\boldsymbol{s}$ avec lequel on fait glisser la fen√™tre correspondant au filtre
                                sur l'image. Par exemple, un
                                pas de $\boldsymbol{1}$ signifie qu'on d√©place la fen√™tre d'un pixel √† la fois.</li>
                            <li>Le zero-padding $\boldsymbol{p}$ : on ajoute √† l'image en entr√©e de la couche un contour
                                noir d'√©paisseur $\boldsymbol{p}$ pixels.
                                Sans ce contour, les dimensions en sortie sont plus petites. Ainsi, plus on empile de
                                couches de
                                convolution avec $\boldsymbol{p = 0}$ , plus l'image en entr√©e du r√©seau r√©tr√©cit. On
                                perd donc beaucoup
                                d'informations rapidement, ce qui rend la t√¢che d'extraction de features difficile.</li>
                        </ol>
                    </div>
                </section>
                <section>
                    <h3>La couche de pooling</h3>
                    <div>
                        <p>La couche de pooling pr√©sente seulement deux hyperparam√®tres :</p>
                        <ol>
                            <li>La taille \boldsymbol{f} des cellules : l'image est d√©coup√©e en cellules carr√©es de
                                taille \boldsymbol{f √ó f} pixels</li>
                            <li>Le pas \boldsymbol{s} : les cellules sont s√©par√©es les unes des autres de \boldsymbol{s}
                                pixels</li>
                        </ol>
                    </div>
                </section>
            </section>

            <section class="main-section">
                <h2>Methodes de r√©gularisation</h2>
                <p>
                    Pour ne pas tomber dans le probl√®me de sur apprentissage il y a des m√©thodes de r√©gularisation √†
                    utiliser.
                </p>
                <section>
                    <h3>Empirique</h3>
                    <section>
                        <h4>Dropout</h4>
                        <p>
                            Les couches "FC" (Fully Connected) occupent la majeure partie de la m√©moire du CNN.
                            D'ailleurs
                            le concept de FC cr√©e un probl√®me exponentiel de m√©moire appel√© "Overfitting"
                            ("sur-connexion"
                            conduisant au sur-apprentissage) ralentissant le traitement de l'information. Pour pr√©venir
                            cela, la m√©thode
                            du dropout est utilis√©e pour "√©teindre" les neurones al√©atoirement (avec une probabilit√©
                            pr√©d√©finie, souvent
                            un neurone sur deux) ainsi que les neurones p√©riph√©riques. Ainsi, avec moins de neurones, le
                            r√©seau est
                            plus r√©actif et peut donc apprendre plus rapidement. √Ä la fin de la s√©ance d'apprentissage,
                            les neurones
                            "√©teints" sont "rallum√©s" (avec leurs poids originaux). Plus la couche FC est proche de
                            l'image source,
                            moins on √©teindra de neurones. L'objectif est d'√©teindre et rallumer les neurones
                            al√©atoirement, dans le cadre
                            d'entra√Ænements successifs. Une fois les s√©ries d'entra√Ænements termin√©es, on rallume tous
                            les neurones et
                            on utilise le r√©seau comme d'habitude. Cette technique a montr√© non seulement un gain dans
                            la vitesse
                            d'apprentissage, mais en d√©connectant les neurones, on a aussi limit√© des effets marginaux,
                            rendant le r√©seau
                            plus robuste et capable de mieux g√©n√©raliser les concepts appris.
                        </p>
                    </section>
                    <section>
                        <h4>DropConnect</h4>
                        <p>Le DropConnect est une √©volution du dropout, o√π on ne va non plus √©teindre un neurone, mais
                            une
                            connexion (l'√©quivalent de la synapse), et ce de mani√®re toujours al√©atoire. Les r√©sultats
                            sont similaires
                            (rapidit√©, capacit√© de g√©n√©ralisation de l'apprentissage), mais pr√©sentent une diff√©rence au
                            niveau de
                            l'√©volution des poids des connexions. Une couche FC avec un DropConnect peut s'apparenter √†
                            une couche
                            √† connexion "diffuse".
                        </p>
                        <ul>
                            <li><span class="bold">La r√©gularisation par norme 1</span> : La sp√©cificit√© de cette
                                r√©gulation est de diminuer le poids des
                                entr√©es al√©atoires et faibles et d'augmenter le poids des entr√©es "importantes". Le
                                syst√®me devient
                                moins sensible au bruit.
                            </li>
                            <li><span class="bold">La r√©gularisation par norme 2</span> : (norme euclidienne) La
                                sp√©cificit√© de cette r√©gulation est de
                                diminuer le poids des entr√©es fortes, et de forcer le neurone √† plus prendre en compte
                                les entr√©es de
                                poids faible.
                            </li>
                        </ul>
                        <p>
                            Les r√©gularisations par norme 1 et norme 2 peuvent √™tre combin√©es : c'est la "r√©gularisation
                            de r√©seau √©lastique" (<span class="bold">Elastic net regulation</span>).
                        </p>
                    </section>
                </section>

                <section>
                    <h3>Explicite</h3>
                    <section>
                        <h4>Taille du r√©seau</h4>
                        <p>
                            La mani√®re la plus simple de limiter le sur apprentissage est de limiter le nombre de
                            couches du r√©seau et
                            de lib√©rer les param√®tres libres (connexions) du r√©seau. Ceci r√©duit directement la
                            puissance et le potentiel
                            pr√©dictif du r√©seau. C'est √©quivalent √† avoir une "norme z√©ro".
                        </p>
                    </section>

                    <section>
                        <h4>D√©gradation du poids</h4>
                        <p>
                            Le concept est de consid√©rer le vecteur des poids d'un neurone (liste des poids associ√©s aux
                            signaux
                            entrants), et de lui rajouter un vecteur d'erreur proportionnel √† la somme des poids (norme
                            1) ou du carr√©
                            des poids (norme 2 ou euclidienne). Ce vecteur d'erreur peut ensuite √™tre multipli√© par un
                            coefficient de
                            proportionnalit√© que l'on va augmenter pour p√©naliser davantage les vecteurs de poids forts.
                        </p>
                    </section>
                </section>
            </section>

            <section id class="main-section conclusion" role="doc-conclusion">
               <h2 class="center">Conclusion</h2>
                <p>
                Dans ce chapitre nous avons √©voqu√© les r√©seaux de neurones du type Feed-forward aussi connu sous
                le nom de R√©seau de type perceptron. Ainsi, nous nous sommes un peu attard√©s sur les perceptrons
                multicouches qui comporte des neurones compl√®tement connect√©s. Nous avons aussi parler de r√©seaux
                neuronal convolutifs. Ces r√©seaux sont capables d‚Äôextraire des caract√©ristiques d‚Äôimages pr√©sent√©es en
                entr√©e et de classifier ces caract√©ristiques. Le succ√®s des CNN ces derni√®res ann√©es d√©pend principalement
                des trois piliers suivants : donn√©es, mod√®le et puissance de calcul.
               </p> 

               <p>
                Les r√©seaux de neurones convolutionnels pr√©sentent cependant un certain nombre de limitations, en
                premier lieu, les hyper param√®tres du r√©seau sont difficiles √† √©valuer a priori. En effet, le nombre de couches,
                les nombre de neurones par couche ou encore les diff√©rentes connexions entre couches sont des √©l√©ments
                cruciaux et essentiellement d√©termin√©s par une bonne intuition ou par une succession de tests/calcul
                d‚Äôerreurs (ce qui est co√ªteux en temps). Le nombre d‚Äô√©chantillons d‚Äôapprentissage est √©galement un √©l√©ment
                d√©terminant, et il arrive souvent que celui‚Äìci soit trop faible en comparaison du nombre de param√®tres
                (poids) du r√©seau. Des solutions existent comme augmenter artificiellement leur nombre ou encore en
                r√©duisant le nombre de param√®tres libres (en r√©alisant un pr√©apprentissage des premi√®res couches par
                exemple).
               </p>

               <p>
                Dans le prochain chapitre, nous allons mettre en pratique les CNN avec l‚Äôimpl√©mentation de notre propre
                mod√®le de deep learning.
               </p>

            </section>
            <footer>
                <p>Coded by
                    <a href="https://github.com/faouziMohamed/" target="_blank" title="Facebook account">
                        FAOUZI MOHAMED
                    </a>
                </p>
            </footer>
        </article>
    </main>
    <a href="#top" class="to-top"></a>
    <script type="text/javascript" src="../js/switch.js"></script>
    <script type="text/javascript" src="../js/nav.js"></script>
    <script type="text/javascript" src="../js/body.js"></script>
    <script type="text/javascript" src="../js/modal-things.js"></script>
    <script type="text/javascript" src="../js/img-slide.js"></script>

    <noscript>
        <div id="noscript-layout">
            <p id="no-script-before-main">
                <i class="fas fa-exclamation-triangle"></i>
                <span>La page web fonctionne bien avec javascript activ√©</span>
            </p>
        </div>
    </noscript>
</body>


</html>